[_] Demo
	[X] implement s/and
	: Think of and as like the fork in workflow diagrams. All paths have to
	: be followed (true). The intention is to compliment the diamond used in
	: or specs.
		[X] move labels on `or` specs onto the lines, rather than having label
		: nodes (do this anyway) (diamond makes sense for or, means decision)
		[X] `and` is like a fork (join), since all paths must be evaluated, so
		: use a black bar-like thing for it.
		[X] get rid of the workd "or" on the or node
		[X] try and re-use or fn to render and
		[X] spread out the and join lines evenly
			[X] finish removing spacing & border around tables
	[X] bump spec version
	[X] filter rendered specs by namespace, since alpha12 includes core specs
	[X] implement s/map-of
	: Torn here. Implementing it like tuple was easy, but still feels like
	: there should be an edge involved between key and value.
	: Hrm, w/ datascope, he just puts a little spacing between the cells. That
	: might work. Also, dropping a small spec-type label in place might work
	: too
	[X] implement s/coll-of
	[_] Code cleanup
		specviz.graphviz -> specviz.graphviz.render
		specviz.core -> specviz.graphviz.spec (only multimethod)
		specviz.core -> specviz.spec (only utils re: spec)
		specviz.util -> specviz.spec (only utils re: spec)j
		specviz.util -> specviz.graphviz (only general graphviz utils)
		In general, we're doing the following:
			Transforming spec into graphviz nodes
				The graphviz nodes should be spec'd
			Rendering the graphviz nodes, to graphviz DSL (dot) text
			Turning the graphviz DSL (dot) text into images
			** We're not trying to decouple things from graphviz **
	[_] Create the demo
		[_] better graphics for (because these are common use cases)
			[_] ad-hoc functions
			[_] sets
			[_] predicates
			: the oval doesn't really say boolean, or function, or anything to
			: me.
	[_] colors
	[_] design a solution for basic regex, maybe just cat + or
	[_] Prune personal info from this TODO
		Remove early preliminary tasks
		Keep design notes


[X] try and navigate to an fspec's first argument
[X] implement `::lookup-ref` spec & print it
[X] implement or spec, w/ arrow to sub-specs
[X] rename the render-X functions, they really just ... do what?
: They are functions that translate a spec s-expr into our simple GraphViz
: DSL. Would like to make this more general than GV (see below).
[X] add predicates to or spec
[X] add nested specs to or spec
: The recursive code in render-or-spec works if render-spec returns one
: node. We might need a slightly different interaction, where each of
: the generator functions product a map w/ drawables, and the name of the
: "head" drawable for that group.
[X] improve aesthetics of or spec
[X] color all named header nodes
[X] fix indentation
[X] make tuple-spec point to subspecs
	[X] named
	: Think we've hit a bigger issue here. In sequential things, we can't
	: just drop an edge to the main spec node & back to the next thing. We
	: need some sort of placeholder. Since we're using filled rectangles
	: for the header nodes of named specs, lets use a regular rectangle,
	: as the placeholder w/ a dotted line to the original.
	[X] unnamed
[X] get rid of arrows on the dotted connections
: The direction of the reference isn't actually wrong, but we want them to
: focus on the arrows used to explain order.
: UPDATE: There are probably other places where direction doesn't make sense,
: like the or branch labels -> spec.
[X] abstract / refactor header/name node -- use it to refactor ::line-direction
[X] fix ::line-direction & ::line-style primitive rendering
: Get rid of record and use box -> box
[X] Fix tuple
: `tuple` looks too much like `or`. Tuple is about a sequence, and should
: really stay all on one line. Is there a way to do this w/ constraints,
: hidden nodes, or possibly w/ records?
:
: Avoid subgraphs as we've reserved them to be used w/ and.
:
: UPDATE: I think again, we've hit the basic *problem* here. Tuple is not just
: composition. And it's not simply order, like we'd use to create the railroad
: diagram of a regex. It's a thing, an entity. It has ordered attributes and
: they have specs.
:
: So it seems like a record w/ a horizontal rendering would work. But if
: there's no header, how do we handle a tuple w/in a tuple? That is, an
: unnamed tuple, an anonymous tuple spec nested w/in a tuple.
	[X] Primitives render in cell
	[X] Anonymous spec connects from cell to spec (put spec type in cell)
	[X] Named spec connects from cell to spec (put spec name in cell)
	[X] Fix the record node abstraction
	: Record nodes have different semantics from the node-trees that represent
	: other specs. Because there's only one node, and the connections if
	: possible are mostly pointers.
	: UPDATE - almost done, just cleanup the remaining TODOs, but the overall
	: abstraction is a lot better.
	[X] Color the named tuple header, like the spec named header node
		Will likely require table implementation
	[X] Try adding paren cells enclosing the tuple record node
	[X] Make sure unnamed tuple specs work
	: That is, things that point to anonymous tuple specs
	[X] Can add better helper fn / dsl around record type?
	: clean up / organize tuple util fns
	: UDPATE: pretty satisfied here, ended up using html stuff. The big
	: `reduce` in tuple is a bit hard to read, but it's important to
	: understand that the concerns of building the table and recursively
	: generating nodes are really related. In other words, separating those
	: things would mean two passes over the rest of the tree.
[X] investigate inspecting specs w/o s/form, like a protocol, api, etc
: There's a protocol, but it doesn't speciy anything besides `describe`, which
: `form` uses. specs for the things produced by describe seems like a good
: idea.
[X] implement s/keys
: keys isn't composition in the same sense of `and`. Rather it's about a
: thing, an entity, so we'll use a record.
: What's different about keys and tuple? tuple is a list of specs, keys is a
: list of keys. But each key doesn't necessarily have to have a spec. You
: think of a tuple like a horizontal list. You probably think of a s/keys
: entity as a vertical table w/ only one column.
[X] Should we render everything from a starting point?
: I think we could leave things pretty much alone, and just walk the tree to
: find all specs of the tree of a top level form.
[X] improve aesthetics of tuple spec
than only sub specs (like `::identifer`)
[X] improve dispatch of case in `render-spec`
[X] finish implementing `render-tuple-or`, use labels, aesthetic
[X] find a better `namespaced-kw?`

[_] Experiences
	Couldn't see the complexity of graphviz initially. As I worked with it,
	: I started evolving my language upward from graphviz, and my program
	: downward toward a digraph layer, hopefully rendering agnostic.
	Specs made things a lot easier to work with, mistakes found early
		Finding errors much higher in the threaded form
		: Instead of "can't make an ISeq from a Keyword, and having to start
		: using println, you know right away. Happened w/ the connection
		: map, w/ an instance of misspelling ::from -> ::form
		Record-layer
		: Forced me to think about whether or not I wanted intermediate
		: structures in the record-dsl.
